#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
lcluster Utility for Trinity Project
"""
__author__      = "Sumit Sharma"
__copyright__   = "Copyright 2022, Luna2 Project [UTILITY]"
__license__     = "GPL"
__version__     = "2.0"
__maintainer__  = "Sumit Sharma"
__email__       = "sumit.sharma@clustervision.com"
__status__      = "Development"

import os
from configparser import RawConfigParser
import subprocess as sp
from threading import Timer
import requests
from prettytable import PrettyTable
from termcolor import colored


class LCluster(object):
    """
    LCluster Class responsible to all Monitoring
    activities.
    """

    def __init__(self):
        """
        Default variables should be here
        before calling the any method.
        """
        self.table = PrettyTable()
        self.node = None
        self.node_hostname = None
        self.statuses = {}
        self.monitor = 'monitoring.clustervision.com'
        self.server_hostname = 'mgm-sensu-01.taurusgroup.one'
        self.server_ip = '192.168.160.55'
        self.server_port = 4567
        self.server_url = f'http://{self.server_ip}:{self.server_port}/'

        self.username, self.password, self.daemon = '', '', ''
        ini_file = '/trinity/local/luna/config/luna.ini'
        file_check = os.path.isfile(ini_file)
        read_check = os.access(ini_file, os.R_OK)
        if file_check and read_check:
            configparser = RawConfigParser()
            configparser.read(ini_file)
            if configparser.has_option('API', 'USERNAME'):
                self.username = configparser.get('API', 'USERNAME')
            if configparser.has_option('API', 'PASSWORD'):
                self.password = configparser.get('API', 'PASSWORD')
            if configparser.has_option('API', 'ENDPOINT'):
                # self.daemon = configparser.get('API', 'ENDPOINT')
                self.daemon = '172.27.220.129:7050'
        else:
            print(f'{ini_file} is not found on this machine.')


    def get_token(self):
        """
        This method will fetch a valid token
        for further use.
        """
        data = {}
        response = False
        data['username'] = self.username
        data['password'] = self.password
        daemon_url = f'http://{self.daemon}/token'
        call = requests.post(url = daemon_url, json=data, timeout=5)
        data = call.json()
        if 'token' in data:
            response = data['token']
        return response


    def health_checkup(self):
        """
        Method to call the class for further
        operations.
        """
        result = []
        get_node_list = self.get_data('config', 'node')
        if get_node_list:
            sno = 1
            for node in get_node_list['config']['node']:
                rows = []
                self.node_hostname = get_node_list['config']['node'][node]['hostname']
                self.node = node
                rows.append(self.get_colored(sno))
                rows.append(self.get_colored(self.node))
                rows.append(self.get_colored(self.node_ipmi()))
                rows.append(self.get_colored(self.node_status()))
                rows.append(self.get_colored(self.slurm_state()))
                rows.append(self.get_colored(self.sensu_state()))
                result.append(rows)
                sno = sno + 1
        if result:
            self.show_table(result)
        else:
            print(colored('No Nodes are available.', 'red', attrs=['bold']))


    def get_colored(self, text=None):
        """
        This method will fetch a records from
        the Luna 2 Daemon Database
        """
        if text is True or text == 'PASS':
            text = colored(text, 'green')
        elif text is False or text == 'CRITICAL':
            text = colored(text, 'red')
        elif text == 'WARNING':
            text = colored(text, 'yellow')
        else:
            text = colored(text, 'blue')
        return text


    def show_table(self, rows=None):
        """
        This method will fetch a records from
        the Luna 2 Daemon Database
        """
        self.table.title = colored('<< Health & Status of Nodes >>', 'cyan', attrs=['bold'])
        fields = ['S. No.', 'Node', 'IPMI', 'Luna', 'SLURM', 'Sensu']
        field = []
        for fieldn in fields:
            field.append(colored(fieldn, 'yellow', attrs=['bold']))
        self.table.field_names = field
        self.table.add_rows(rows)
        print(self.table)
        return True


    def get_data(self, route=None, uri=None):
        """
        This method is based on REST API's GET method.
        It will fetch the records from Luna 2 Daemon
        via REST API's.
        """
        response = False
        headers = {'x-access-tokens': self.get_token()}
        daemon_url = f'http://{self.daemon}/{route}'
        if uri:
            daemon_url = f'{daemon_url}/{uri}'
        call = requests.get(url=daemon_url, headers=headers, timeout=5)
        if call:
            response = call.json()
        return response


    def node_ipmi(self):
        """
        This method is based on REST API's GET method.
        It will fetch the records from Luna 2 Daemon
        via REST API's.
        """
        response = False
        headers = {'x-access-tokens': self.get_token()}
        daemon_url = f'http://{self.daemon}/control/power/{self.node}/_status'
        call = requests.get(url=daemon_url, headers=headers, timeout=5)
        if call:
            data = call.json()
            response = data['control']['status']
        return response


    def node_status(self):
        """
        This method is based on REST API's GET method.
        It will fetch the records from Luna 2 Daemon
        via REST API's.
        """
        response = False
        headers = {'x-access-tokens': self.get_token()}
        daemon_url = f'http://{self.daemon}/monitor/status/{self.node}'
        call = requests.get(url=daemon_url, headers=headers, timeout=5)
        if call:
            data = call.json()
            response = data['monitor']['status'][self.node]['state']
        return response


    def sensu_state(self):
        """
        This method is based on REST API's GET method.
        It will fetch the records from Luna 2 Daemon
        via REST API's.
        """
        response = 'PASS'
        self.node = 'f00f.taurusgroup.one'
        sensu_url = f'{self.server_url}events/{self.node}'
        call = requests.get(url=sensu_url, timeout=5)
        data = call.json()
        if data:
            status = data[0]['check']['status']
            if status == 1:
                response = "WARNING"
            elif status == 2:
                response = "CRITICAL"
        return response


    def slurm_state(self):
        """
        Returns stdout for
        sinfo -N -o "%N %6T"
        """
        response = False
        cmd = 'sinfo -N -o "%N %6T"'
        return_code, stdout, _, _ = self.run_cmd(cmd)

        if return_code:
            return False
            # return self.statuses

        for line in stdout.split("\n"):
            line = line.split()
            if len(line) < 2:
                continue
            nodename = line[0]
            status = line[1]
            if nodename not in self.statuses:
                self.statuses[nodename] = set()
            self.statuses[nodename].add(status)
            response = "/".join(self.statuses[self.node])

        return response


    def run_cmd(self, cmd=None, timeout=30):
        """
        Returns 'return_code', 'stdout', 'stderr', 'exception'
        Where 'exception' is a content of Python exception if any
        """
        return_code = 255
        stdout, stderr, exception = "", "", ""
        try:
            proc = sp.Popen(cmd, shell=True, stdout=sp.PIPE, stderr=sp.PIPE)
            timer = Timer(timeout, lambda p: p.kill(), [proc])
            try:
                timer.start()
                stdout, stderr = proc.communicate()
            except sp.TimeoutExpired as exp:
                print(f"Subprocess Timeout executing {exp}")
            finally:
                timer.cancel()
            proc.wait()
            return_code = proc.returncode
        except sp.SubprocessError as exp:
            print(f"Subprocess Error executing {cmd} Exception is {exp}")
            exception = exp
        return return_code, stdout, stderr, exception


if __name__ == "__main__":
    LCluster().health_checkup()
